# Начало работы с Node.js

## Node.js в двух словах

##### Начало работы с Node.js

![](http://blog-assets.risingstack.com/2016/Mar/node_js_logo_in_node_hero_getting_started_tutorial-1458726703612.png)

_Официальное лого Node.js_

---

## Node.js

Node.js — это опенсорсная кроссплатформенная среда выполнения для JavaScript, которая работает на серверах. С момента выпуска этой платформы в 2009 году она стала чрезвычайно популярной и в наши дни играет весьма важную роль в области веб-разработки. Если считать показателем популярности число звёзд, которые собрал некий проект на GitHub, то Node.js, у которого более 50000 звёзд, это очень и очень популярный проект.

Платформа Node.js построена на базе JavaScript движка V8 от Google, который используется в браузере Google Chrome. Данная платформа, в основном, используется для создания веб-серверов, однако сфера её применения этим не ограничивается.

Рассмотрим основные особенности Node.js.

▍Скорость

Одной из основных привлекательных особенностей Node.js является скорость. JavaScript-код, выполняемый в среде Node.js, может быть в два раза быстрее, чем код, написанный на компилируемых языках, вроде C или Java, и на порядки быстрее интерпретируемых языков наподобие Python или Ruby. Причиной подобного является неблокирующая архитектура платформы, а конкретные результаты зависят от используемых тестов производительности, но, в целом, Node.js — это очень быстрая платформа.

▍Простота

Платформа Node.js проста в освоении и использовании. На самом деле, она прямо-таки очень проста, особенно это заметно в сравнении с некоторыми другими серверными платформами.

▍JavaScript

В среде Node.js выполняется код, написанный на JavaScript. Это означает, что миллионы фронтенд-разработчиков, которые уже пользуются JavaScript в браузере, могут писать и серверный, и клиентский код на одном и том же языке программирования без необходимости изучать совершенно новый инструмент для перехода к серверной разработке.
В браузере и на сервере используются одинаковые концепции языка. Кроме того, в Node.js можно оперативно переходить на использование новых стандартов ECMAScript по мере их реализации на платформе. Для этого не нужно ждать до тех пор, пока пользователи обновят браузеры, так как Node.js — это серверная среда, которую полностью контролирует разработчик. В результате новые возможности языка оказываются доступными при установке поддерживающей их версии Node.js.

▍Движок V8

В основе Node.js, помимо других решений, лежит опенсорсный JavaScript-движок V8 от Google, применяемый в браузере Google Chrome и в других браузерах. Это означает, что Node.js пользуется наработками тысяч инженеров, которые сделали среду выполнения JavaScript Chrome невероятно быстрой и продолжают работать в направлении совершенствования V8.

▍Асинхронность

В традиционных языках программирования (C, Java, Python, PHP) все инструкции, по умолчанию, являются блокирующими, если только разработчик явным образом не позаботится об асинхронном выполнении кода. В результате если, например, в такой среде, произвести сетевой запрос для загрузки некоего JSON-кода, выполнение потока, из которого сделан запрос, будет приостановлено до тех пор, пока не завершится получение и обработка ответа.

JavaScript значительно упрощает написание асинхронного и неблокирующего кода с использованием единственного потока, функций обратного вызова (коллбэков) и подхода к разработке, основанной на событиях. Каждый раз, когда нам нужно выполнить тяжёлую операцию, мы передаём соответствующему механизму коллбэк, который будет вызван сразу после завершения этой операции. В результате, для того чтобы программа продолжила работу, ждать результатов выполнения подобных операций не нужно.

Для этого был придуман механизм [event loop](https://www.youtube.com/watch?v=8cV4ZvHXQL4)

Подобный механизм возник в браузерах. Мы не можем позволить себе ждать, скажем, окончания выполнения AJAX-запроса, не имея при этом возможности реагировать на действия пользователя, например, на щелчки по кнопкам. Для того чтобы пользователям было удобно работать с веб-страницами, всё, и загрузка данных из сети, и обработка нажатия на кнопки, должно происходить одновременно, в режиме реального времени.

Если вы создавали когда-нибудь обработчик события нажатия на кнопку, то вы уже пользовались методиками асинхронного программирования.

Асинхронные механизмы позволяют единственному Node.js-серверу одновременно обрабатывать тысячи подключений, не нагружая при этом программиста задачами по управлению потоками и по организации параллельного выполнения кода. Подобные вещи часто являются источниками ошибок.

Node.js предоставляет разработчику неблокирующие базовые механизмы ввода вывода, и, в целом, библиотеки, использующиеся в среде Node.js, написаны с использованием неблокирующих парадигм. Это делает блокирующее поведение кода скорее исключением, чем нормой.

Когда Node.js нужно выполнить операцию ввода-вывода, вроде загрузки данных из сети, доступа к базе данных или к файловой системе, вместо того, чтобы заблокировать ожиданием результатов такой операции главный поток, Node.js инициирует её выполнение и продолжает заниматься другими делами до тех пор, пока результаты выполнения этой операции не будут получены.

[Node js вступление](https://habr.com/company/ruvds/blog/422893/)

### Знакомство с Server-side JavaScript

Изначально JavaScript запускался в браузере, осуществлялось посредством “движка” v8.

Чтобы ваш JavaScript код выполнился на вычислительной машине вне браузера (на backend), он должен быть интерпретирован и, конечно же, выполнен. Именно это и делает Node.js. Для этого он использует движок V8 VM от Google — ту же самую среду исполнения для JavaScript, которую использует браузер Google Chrome.

Кроме того, Node.js поставляется со множеством полезных модулей, так что вам не придется писать всё с нуля, как, например, вывод строки в консоль.

Таким образом, Node.js состоит из 2 вещей: среды исполнения и полезных библиотек.

_Node.js — это среда выполнения JavaScript, построенная на JavaScript-движке V8 из Chrome. В основе Node.js лежит **событийно-управляемая модель с неблокирующими операциями I/O**, что делает её легкой и эффективной._

Другими словами: Node.js предлагает вам возможность писать невероятно производительный серверный код с использованием JavaScript. Как говорится в официальном описании: Node.js — это среда выполнения, использующая тот же JavaScript-движок V8, который вы можете найти в браузере Google Chrome. Но этого недостаточно для успеха Node.js. В Node.js используется libuv - кросс-платформенная библиотека поддержки с акцентом на асинхронный ввод-вывод.

![](http://blog-assets.risingstack.com/2016/Mar/libuv_logo_in_node_hero_getting_started_tutorial-1458726737329.png)

_Официальное лого libuv_

С точки зрения разработчика, Node.js однопоточна, но под капотом **libuv использует треды, события файловой системы, реализует цикл событий, включает в себя тред-пулинг** и так далее. В большинстве случаев вы не будете взаимодействовать с libuv напрямую.

## Установка Node.js

Чтобы установить Node на компьютер, вам нужно пойти на сайт
[https://nodejs.org/uk/](https://nodejs.org/uk/) и скачать LTSили текущую версию (на момент
написания методички это были версии v10.16.0 и v12.6.0 соответственно).

#### А что делать, если вы хотите установить эти две версии сразу?

Для этого есть специальная утилита [nvm](https://github.com/creationix/nvm) (Node Version Manager)— это скрипт, который позволяет устанавливать, переключать и удалять версии Node.js т.е. даёт возможность держать на одной машине любое количество версий Node.js.

**Хорошо, теперь мы знаем, как устанавливать Node.js и переключаться между её версиями, но в чём смысл?**

С тех пор как был сформирован Node.js Foundation, Node.js имеет план релизов. Это очень похоже на другие проекты Linux Foundation. Это означает, что есть два релиза: стабильный и экспериментальный. В Node.js стабильными версиями с долговременной поддержкой (LTS) являются те, которые начинаются с четных чисел (4, 6, 8, ...). Экспериментальные версии нумеруются нечетными числами (5, 7, ...).

Мы рекомендуем использовать версию LTS в продакшене и пробовать новые возможности с экспериментальной версией.

Чтобы проверить работоспособность после установки наберите в консоли:

```

node -v

```

Проверяем версию Node.js (node -v) - получаем текущую версию.
Если все в порядке, эта команда вернет номер версии текущего активного бинарного файла Node.js.

**Доступны многие методы, за исключением Alert и работы с DOM-деревом, но можно вызвать привычное console.log**

---

## Hello World

Чтобы начать работу с Node.js, давайте попробуем её в консоли!
Запустите Node.js, просто наберите в консоли `node`:

```

$ node

>

```

и нажмите Enter (return для Mac) - данная команда откроет интерактивный режим в командной строке - интерактивная консоль node, прямо в которой можно набирать и выполнять команды JavaScript.

Хорошо, давайте попробуем что-то напечатать:

```
> 1+2
> 3
```

В этом режиме в консоль просто выводится результат набранного выражения.  
А теперь наберите:

```
$ node >

> console.log(‘Hello World’);

> Hello World

> undefined
```

В этом примере просто набираем “console.log(‘Hello World’);” и нажимаем на Enter. Node начнет выполнять, и мы увидим наше сообщение. Также он напишет “undefined”, потому что печатает возвращаемое значение, и console.log не возвращает ничего.

---

Другой способ использования Node.js — это создание файла Javascript.

Пришло время создать наше приложение Hello Node.js!

Начнем с создания файла `index.js`. Откройте свою IDE (Atom, Sublime, Code — выбор за вами), создайте новый файл и сохраните его с именем `index.js`. Если вы закончили, скопируйте в него следующий фрагмент кода:

```

// index.js

console.log('hello from Node.js')

```

Чтобы запустить этот файл, вы должны снова открыть свой терминал и перейти в каталог, в котором размещён `index.js`.

Как только вы успешно переместитесь в нужное место, запустите файл, используя команду `node index.js`. Вы увидите, что эта команда будет выдавать тот же результат, что и раньше, выводя строку непосредственно в терминале.

## КакработаетNode?

В основе Node лежит библиотека **libuv**, реализующая цикл событий **event loop**.

Мы знаем, что объявленная переменная в скрипте автоматически становится глобальной. В Node она остается локальной для текущего модуля и чтобы сделать ее глобальной, надо объявить ее как свойство объекта **Global**:

```
global.foo = 3;
```

Фактически, объект **Global** — это аналог объекта window из браузера.

Метод **require,** служащий для подключения модулей, не является глобальным и локален для каждого модуля.

Также локальными для каждого модуля являются:

module.export– объект, отвечающий за то, что именно будет экспортировать модуль при использовании require;

\_filename – имя файла исполняемого скрипта;

\_dirname – абсолютный путь до исполняемого скрипта.

В секцию **Global** входят такие важные элементы как:

**Class: Buffer** – объект используется для операций с бинарными данными.

**Process** – объект процесса, большая часть данных находится именно здесь.

Приведем пример работы некоторых из них. Назначение понятно из названий:

```
console.log(process.execPath);
console.log(process.version);
console.log(process.platform);
console.log(process.arch);
console.log(process.title);
console.log(process.pid);
```

**process.execPath** — укажет абсолютный путь к исполняемому файлу, который запустил данный процесс.
**process.version** - предоставляет NODE_VERSION.
**process.platform** - укажет на какой платформе вы работаете: ‘darwin’, ‘freebsd’, ‘linux’, ‘sunos’ или ‘win32′,
**process.arch** - укажет в какой процессорной архитектуре вы работаете: ‘arm’, ‘ia32′ или ‘x64′,
**process.title** - Getter/setter, который задает что выводить ‘ps’,
**process.pid** — PID процесса.

Свойство **process.argv** содержит массив аргументов командной строки. Первым аргументом будет имя исполняемого приложения node, вторым имя самого исполняемого сценария и только потом сами параметры.

Для работы с каталогами есть следующие свойства – **process.cwd()** возвращает текущий рабочий каталог, **process.chdir()** выполняет переход в другой каталог.

Команда **process.exit()** завершает процесс с указанным в качестве аргумента кодом: 0 – успешный код, 1 – код с ошибкой.

Важный метод **process.nextTick(fn)** запланирует выполнение указанной функции таким образом, что указанная функция будет выполнена после окончания текущей фазы (текущего исполняемого кода), но перед началом следующей фазы eventloop.

```
process.nextTick(function() {
console.log(‘NextTick callback’);
}
```

ОбъектProcess содержит еще много свойств и методов, с которыми можно ознакомиться в
[справке](https://nodejs.org/api/process.html).

## События

За события в Node.js отвечает специальный модуль events. Назначать объекту обработчик события следует методом **addListener(event, listener)**. Аргументы – это имя события event в camelCase формате и listener— функция обратного вызова, обработчик события. Для этого метода есть более короткая запись **on()**.

Удалить обработчик можно методом **removeListener(event, listener)**. А метод **emit(event, [args])** позволяет событиям срабатывать.

Например, событие **exit** отправляется перед завершением работы Node.

```
process.on('exit' , function() { console.log('Bye!');});
```

# Модули

Для подключения к вашим скриптам дополнительных функций в Node. js существует удобная система управления модулями NPM. По сути это публичный репозиторий созданных при помощи Node.js дополнительных программных модулей.

Команда npm позволяет легко устанавливать, удалять или обновлять нужные вам модули, автоматически учитывая при этом все зависимости выбранного вами модуля от других.

Установка модуля производится командой:

npm install "имя модуля" [ключи]
Для установки модуля будет использована поддиректория node_modules.

Хотя node_modulesи содержит все необходимые для запуска зависимости, распространять исходный код вместе с ней не принято, т.к. в ней может храниться большое количество файлов, которые занимают ощутимый объем и это неудобно.

С учетом того, что все публичные NPM-модули можно легко установить с помощью npm, достаточно создать и написать для вашей программы файл package.jsonс перечнем всех необходимых для работы зависимостейи потом просто, на новом месте, например, установить все нужные модули командой:

```
$ npm install
```

Node.js работает с системой подключения модулей CommonJS. В структурном плане, CommonJS-модуль представляет собой готовый к новому использованию фрагмент JavaScript-кода, который экспортирует специальные объекты, доступные для использования в любом зависимом коде. CommonJS используется как формат JavaScript-модулей так же и на front-end. Две главных идеи CommonJS-модулей: объект exports, содержащий то, что модуль хочет сделать доступным для других частей системы, и функцию require, которая используется одними модулями для импорта объекта exports из других.

Начиная с версии 6.х Node.js так же поддерживает подключение модулей согласно стандарту ECMAScript-2015.

Давайте попробуем что-нибудь подключить. Например, модуль [colors](https://www.npmjs.com/package/colors) можно подключить в любой из уже существующих файлов index.js и немного переписать его, или создать новый проект. Наш скрипт должен выглядеть так:

```
let colors = require('colors');
let text = 'Hello student!';
console.log(text.rainbow);
```

Выполним команды в консоли:

```
npm i colors
node index.js
```

И теперь наша надпись должна стать разноцветной.

## Модульность для вашего приложения

Теперь у вас есть файл `index.js`, поэтому пришло время перейти на следующий уровень! Давайте создадим что-то более сложное, разделив наш исходный код на несколько JavaScript-файлов с целью удобочитаемости и поддерживаемости. Чтобы начать работу, вернитесь в свою IDE и создайте следующую структуру каталогов (с пустыми файлами), но пока не трогайте `package.json`, мы сгенерируем его автоматически на следующем шаге:

```

├── app

| ├── calc.js

| └── index.js

├── index.js

└── package.json

```

Каждый проект Node.js начинается с создания файла `package.json`. Вы можете думать о нем как о JSON-представлении приложения и его зависимостей. Он содержит имя вашего приложения, автора (вас) и все зависимости, необходимые для запуска приложения.

Вы можете интерактивно генерировать файл `package.json` с помощью команды `npm init` в терминале. После запуска команды вас попросят ввести некоторые данные, например имя вашего приложения, версию, описание и так далее. Не нужно беспокоиться, просто нажимайте Enter, пока не получите сформированный JSON и вопрос `is it ok?`. Нажмите Enter в последний раз и вуаля: ваш `package.json` был автоматически сгенерирован и помещен в папку вашего приложения.

Можно сократить процес и сразу задать `npm init -y`. И уже готовый файл `package.json` редактировать в вашей IDE.

Если вы откроете сгенерированный `package.json` в своей IDE, он будет очень похож на фрагмент кода ниже.

```javascript

// package.json

{

"name": "@node-project",

"version": "1.0.0",

"description": "",

"main": "index.js",

"scripts": {

"test":  "echo \"Error: no test specified\" && exit 1",

"start":  "node index.js"

},

"author": "", "license": "ISC"

}

```

Хорошей практикой является добавление стартового скрипта в ваш пакет `package.json`. Как только вы это сделаете, как показано в примере выше, вы можете запустить приложение с помощью команды `npm start`. Это очень удобно, когда вы хотите развернуть свое приложение у PaaS-провайдера: они могут распознать команду `start` и использовать её для запуска приложения.

Теперь давайте вернемся к первому созданному вами файлу под названием `index.js`. Я рекомендую оставить этот файл очень компактным: только подключение самого приложения (файл `index.js` из подкаталога `/app`, созданного ранее). Скопируйте следующий код в свой файл `index.js` и сохраните:

```javascript
// index.js

require("./app/index");
```

Теперь пришло время приступить к созданию реального приложения. Откройте файл `index.js` из папки `/app`, чтобы создать очень простой пример: добавление массива чисел. В этом случае файл `index.js` будет содержать только числа, которые мы хотим добавить, а логика, требующая вычислений, должна быть помещена в отдельный модуль.

Вставьте этот код в файл `index.js` в каталоге `/app`.

```javascript
// app/index.js

const calc = require("./calc");

const numbersToAdd = [
  3,

  4,

  10,

  2,
];

const result = calc.sum(numbersToAdd);

console.log(`The result is: ${result}`);
```

Теперь вставьте фактическую бизнес-логику в файл `calc.js`, который можно найти в той же папке.

```javascript
// app/calc.js

function sum(arr) {
  return arr.reduce(function (a, b) {
    return a + b;
  }, 0);
}

module.exports.sum = sum;
```

Чтобы проверить, всё ли вы сделали правильно, сохраните эти файлы, откройте терминал и введите `npm start` или `node index.js`. Если вы все сделали правильно, вы получите ответ: 19. Если что-то пошло не так, внимательно просмотрите лог в консоли и найдите проблему на его основе.

---

Для примера можете запустить два проекта (/00_1_Alert, /01_2_Variable), которые лежат в каталоге lesson_1/01_Introduce to NodeJS. Необходимо перейти в соответсующую папку, открыть терминал и ввести `node index.js`.

# node.js_additional-materials
