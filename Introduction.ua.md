# Початок роботи з Node.js

## Node.js у двох словах

##### Початок роботи з Node.js

![](http://blog-assets.risingstack.com/2016/Mar/node_js_logo_in_node_hero_getting_started_tutorial-1458726703612.png)

_Офіційне лого Node.js_

---

## Node.js

Node.js - це опенсорсне кросплатформове середовище виконання для JavaScript, яке працює на серверах. З моменту випуску цієї платформи в 2009 році вона стала надзвичайно популярною і у наші дні відіграє важливу роль у галузі веб-розробки. Якщо вважати показником популярності кількість зірок, які зібрав якийсь проект на GitHub, то Node.js, у якого понад 50000 зірок, це дуже популярний проект.

Платформа Node.js побудована на базі JavaScript двигун V8 від Google, який використовується в браузері Google Chrome. Ця платформа в основному використовується для створення веб-серверів, проте сфера її застосування цим не обмежується.

Розглянемо основні особливості Node.js.

▍Швидкість

Однією з основних привабливих особливостей Node.js є швидкість. JavaScript-код, що виконується в середовищі Node.js, може бути вдвічі швидше, ніж код, написаний компілюваними мовами, на кшталт C або Java, і на порядки швидше за інтерпретовані мови на кшталт Python або Ruby. Причиною подібного є неблокуюча архітектура платформи, а конкретні результати залежать від продуктивності, що використовуються, але, в цілому, Node.js - це дуже швидка платформа.

▍Простота

Платформа Node.js проста в освоєнні та використанні. Насправді, вона просто проста, особливо це помітно в порівнянні з деякими іншими серверними платформами.

▍JavaScript

У Node.js виконується код, написаний на JavaScript. Це означає, що мільйони фронтенд-розробників, які вже користуються JavaScript у браузері, можуть писати і серверний, і клієнтський код тією ж мовою програмування без необхідності вивчати зовсім новий інструмент для переходу до серверної розробки.
У браузері та сервері використовуються однакові концепції мови. Крім того, Node.js можна оперативно переходити на використання нових стандартів ECMAScript у міру їх реалізації на платформі. Для цього не потрібно чекати, поки користувачі оновлять браузери, оскільки Node.js — це серверне середовище, яке повністю контролює розробник. В результаті нові можливості мови виявляються доступними при встановленні версії Node.js, що підтримує їх.

▍Двигун V8

В основі Node.js, окрім інших рішень, лежить опенсорсний JavaScript-движок V8 від Google, який використовується в браузері Google Chrome та інших браузерах. Це означає, що Node.js користується напрацюваннями тисяч інженерів, які зробили середовище виконання JavaScript Chrome неймовірно швидким і продовжують працювати у напрямку вдосконалення V8.

▍Асинхронність

У традиційних мовах програмування (C, Java, Python, PHP) всі інструкції за замовчуванням є блокуючими, якщо тільки розробник явно не подбає про асинхронне виконання коду. В результаті якщо, наприклад, у такому середовищі, зробити мережевий запит для завантаження якогось JSON-коду, виконання потоку, з якого зроблений запит, буде припинено доти, доки не завершиться отримання та обробка відповіді.

JavaScript значно спрощує написання асинхронного та неблокуючого коду з використанням єдиного потоку, функцій зворотного виклику (коллбеків) та підходу до розробки, що базується на подіях. Щоразу, коли нам потрібно виконати важку операцію, ми передаємо відповідному механізму коллбек, який буде викликаний одразу після завершення цієї операції. В результаті, щоб програма продовжила роботу, чекати результатів виконання подібних операцій не потрібно.

Для цього було придумано механізм [event loop](https://www.youtube.com/watch?v=8cV4ZvHXQL4)

Подібний механізм виник у браузерах. Ми не можемо дозволити собі чекати, скажімо, закінчення виконання AJAX-запиту, не маючи при цьому можливості реагувати на дії користувача, наприклад на клацання по кнопках. Для того, щоб користувачам було зручно працювати з веб-сторінками, все, і завантаження даних з мережі, і обробка натискання на кнопки має відбуватися одночасно, в режимі реального часу.

Якщо ви створювали колись обробник події натискання на кнопку, то ви вже користувалися методиками асинхронного програмування.

Асинхронні механізми дозволяють єдиному Node.js-серверу одночасно обробляти тисячі підключень, не навантажуючи при цьому програміста завданнями з управління потоками та організації паралельного виконання коду. Такі речі часто є джерелами помилок.

Node.js надає розробнику неблокуючі базові механізми введення висновку, і, загалом, бібліотеки, що використовуються в середовищі Node.js, написані з використанням парадигм, що не блокують. Це робить блокуючу поведінку коду швидше винятком, ніж нормою.

Коли Node.js потрібно виконати операцію введення-виводу, на кшталт завантаження даних з мережі, доступу до бази даних або файлової системи, замість того, щоб заблокувати очікуванням результатів такої операції головний потік, Node.js ініціює її виконання і продовжує займатися іншими справами до поки результати виконання цієї операції не будуть отримані.

[Node js вступ](https://habr.com/company/ruvds/blog/422893/)

### Знайомство з Server-side JavaScript

Спочатку JavaScript запускався в браузері, здійснювалося за допомогою "движка" v8.

Щоб ваш JavaScript код виконався на обчислювальній машині поза браузером (на backend), він повинен бути інтерпретований і, звичайно ж, виконаний. Саме це робить Node.js. Для цього він використовує двигун V8 VM від Google - те саме середовище виконання для JavaScript, яку використовує браузер Google Chrome.

Крім того, Node.js поставляється з багатьма корисними модулями, так що вам не доведеться писати все з нуля, як, наприклад, виведення рядка в консоль.

Таким чином, Node.js складається з 2 речей: середовища виконання та корисних бібліотек.

_Node.js — это среда выполнения JavaScript, построенная на JavaScript-движке V8 из Chrome. В основе Node.js лежит **событийно-управляемая модель с неблокирующими операциями I/O**, что делает её легкой и эффективной._

Другими словами: Node.js предлагает вам возможность писать невероятно производительный серверный код с использованием JavaScript. Как говорится в официальном описании: Node.js — это среда выполнения, использующая тот же JavaScript-движок V8, который вы можете найти в браузере Google Chrome. Но этого недостаточно для успеха Node.js. В Node.js используется libuv - кросс-платформенная библиотека поддержки с акцентом на асинхронный ввод-вывод.

![](http://blog-assets.risingstack.com/2016/Mar/libuv_logo_in_node_hero_getting_started_tutorial-1458726737329.png)

_Офіційне лого libuv_

З точки зору розробника, Node.js однопоточна, але під капотом ** libuv використовує треди, події файлової системи, реалізує цикл подій, включає тред-пулінг ** і так далі. У більшості випадків ви не будете взаємодіяти з libuv безпосередньо.

## Встановлення Node.js

Щоб встановити Node на комп'ютер, ви повинні піти на сайт
[https://nodejs.org/uk/](https://nodejs.org/uk/) та завантажити LTSабо поточну версію (на момент
написання методички це були версії v10.16.0 та v12.6.0 відповідно).

#### А що робити, якщо ви хочете встановити ці дві версії відразу?

Для цього є спеціальна утиліта [nvm] (https://github.com/creationix/nvm) (Node Version Manager) - це скрипт, який дозволяє встановлювати, перемикати та видаляти версії Node.js тобто. дозволяє тримати на одній машині будь-яку кількість версій Node.js.

**Добре, тепер ми знаємо, як встановлювати Node.js і перемикатися між її версіями, але в чому сенс?**

Відколи був сформований Node.js Foundation, Node.js має план релізів. Це дуже схоже інші проекти Linux Foundation. Це означає, що є два релізи: стабільний та експериментальний. У Node.js стабільними версіями з довготривалою підтримкою (LTS) є ті, що починаються з парних чисел (4, 6, 8, ...). Експериментальні версії нумеруються непарними числами (5, 7, ...).

Ми рекомендуємо використовувати версію LTS у продакшені та пробувати нові можливості з експериментальною версією.

Щоб перевірити працездатність після встановлення наберіть у консолі:

```

node -v

```

Перевіряємо версію Node.js (node -v) – отримуємо поточну версію.
Якщо все гаразд, ця команда поверне номер версії активного бінарного файлу Node.js.

**Доступні багато методів, за винятком Alert та роботи з DOM-деревом, але можна викликати звичне console.log**

---

## Hello World

Щоб почати роботу з Node.js, спробуймо її в консолі!
Запустіть Node.js, просто наберіть у консолі `node`:

```

$ node

>

```

та натисніть Enter (return для Mac) - дана команда відкриє інтерактивний режим у командному рядку - інтерактивна консоль node, прямо в якій можна набирати та виконувати команди JavaScript.

Добре, давайте спробуємо щось надрукувати:

```
> 1+2
> 3
```

У цьому режимі консоль просто виводиться результат набраного виразу.
А тепер наберіть:

```
$ node >

> console.log(‘Hello World’);

> Hello World

> undefined
```

У цьому прикладі просто набираємо “console.log(“Hello World”);” та натискаємо на Enter. Node почне виконувати і ми побачимо наше повідомлення. Також він напише “undefined”, тому що друкує значення, що повертається, і console.log не повертає нічого.

---

Інший спосіб використання Node.js – це створення файлу Javascript.

Настав час створити наш додаток Hello Node.js!

Почнемо зі створення файлу `index.js`. Відкрийте свою IDE (Atom, Sublime, Code - вибір за вами), створіть новий файл та збережіть його з ім'ям `index.js`. Якщо ви закінчили, скопіюйте в нього наступний фрагмент коду:

```

// index.js

console.log('hello from Node.js')

```

Щоб запустити цей файл, ви повинні знову відкрити термінал і перейти в каталог, в якому розміщений `index.js`.

Як тільки ви успішно переміститесь в потрібне місце, запустіть файл, використовуючи команду 'node index.js'. Ви побачите, що ця команда видаватиме той самий результат, що й раніше, виводячи рядок у терміналі.

## Як працює Node?

В основі Node лежить бібліотека libuv, що реалізує цикл подій event loop.

Ми знаємо, що оголошена змінна у скрипті автоматично стає глобальною. У Node вона залишається локальною для поточного модуля і щоб зробити її глобальною, треба оголосити її як властивість об'єкта.

```
global.foo = 3;
```

Фактично, об'єкт Global - це аналог об'єкта window з браузера.

Метод **require,** службовець для підключення модулів, є глобальним і локальний кожному за модуля.

Також локальними для кожного модуля є:

module.export– об'єкт, що відповідає за те, що саме експортуватиме модуль при використанні require;

\_filename - Ім'я файлу виконуваного скрипта;

\_dirname - абсолютний шлях до виконуваного скрипта.

До секції **Global** входять такі важливі елементи як:

**Class: Buffer** – об'єкт використовується для операцій із бінарними даними.

**Process** – об'єкт процесу, більшість даних перебуває саме тут.

Наведемо приклад роботи деяких із них. Призначення зрозуміло з назв:

```
console.log(process.execPath);
console.log(process.version);
console.log(process.platform);
console.log(process.arch);
console.log(process.title);
console.log(process.pid);
```

**process.execPath** — вкаже абсолютний шлях до виконуваного файлу, який запустив цей процес.
**process.version** - надає NODE_VERSION.
**process.platform** - вкаже на якій платформі ви працюєте: 'darwin', 'freebsd', 'linux', 'sunos' або 'win32',
**process.arch** - вкаже в якій процесорній архітектурі ви працюєте: 'arm', 'ia32' або 'x64',
**process.title** - Getter/setter, який задає що виводити 'ps',
**process.pid** - PID процесу.

Властивість **process.argv** містить масив аргументів командного рядка. Першим аргументом буде ім'я програми, що виконується, node, другим ім'я самого виконуваного сценарію і тільки потім самі параметри.

Для роботи з каталогами є такі властивості: **process.cwd()** повертає поточний робочий каталог, **process.chdir()** виконує перехід до іншого каталогу.

Команда **process.exit()** завершує процес із зазначеним як аргумент кодом: 0 – успішний код, 1 – код з помилкою.

Важливий метод **process.nextTick(fn)** запланує виконання зазначеної функції таким чином, що зазначена функція буде виконана після закінчення поточної фази (поточного коду), але перед початком наступної фази eventloop.

```
process.nextTick(function() {
console.log(‘NextTick callback’);
}
```

Об'єктProcess містить ще багато властивостей та методів, з якими можна ознайомитись у
[довідка](https://nodejs.org/api/process.html).

## Події

За події у Node.js відповідає спеціальний модуль events. Призначати об'єкту обробник події слід методом addListener (event, listener). Аргументи - це ім'я події event в форматі camelCase і listener- функція зворотного виклику, обробник події. Для цього є більш короткий запис **on()**.

Видалити обробник можна методом removeListener(event, listener)**. А метод **emit(event, [args])** дозволяє подіям спрацьовувати.

Наприклад, подія **exit** відправляється перед завершенням роботи Node.

```
process.on('exit' , function() { console.log('Bye!');});
```

# Модулі

Для підключення до ваших скриптів додаткових функцій у Node. js існує зручна система керування модулями NPM. По суті, це публічний репозиторій створених за допомогою Node.js додаткових програмних модулів.

Команда npm дозволяє легко встановлювати, видаляти або оновлювати потрібні модулі, автоматично враховуючи при цьому всі залежності обраного вами модуля від інших.

Установка модуля виконується командою:

npm install "ім'я модуля" [ключи]
Для встановлення модуля буде використано піддиректорію node_modules.

Хоча node_modules містить всі необхідні для запуску залежності, поширювати вихідний код разом з нею не прийнято, т.к. в ній може зберігатись велика кількість файлів, які займають відчутний об'єм і це незручно.

З урахуванням того, що всі публічні NPM-модулі можна легко встановити за допомогою npm, достатньо створити та написати для вашої програми файл package.jsonз переліком усіх необхідних для роботи залежності потім просто, на новому місці, наприклад, встановити всі потрібні модулі командою:

```
$ npm install
```

Node.js працює із системою підключення модулів CommonJS. У структурному плані, CommonJS-модуль є готовим до нового використання фрагментом JavaScript-коду, який експортує спеціальні об'єкти, доступні для використання в будь-якому залежному коді. CommonJS використовується як формат JavaScript-модулів так і на front-end. Дві головні ідеї CommonJS-модулів: об'єкт exports, що містить те, що модуль хоче зробити доступним для інших частин системи, та функцію require, яка використовується одними модулями для імпорту об'єкта exports з інших.

Починаючи з версії 6.х, Node.js також підтримує підключення модулів відповідно до стандарту ECMAScript-2015.

Давайте спробуємо щось підключити. Наприклад, модуль [colors](https://www.npmjs.com/package/colors) можна підключити до будь-якого з вже існуючих файлів index.js і трохи переписати його, або створити новий проект. Наш скрипт має виглядати так:

```
let colors = require('colors');
let text = 'Hello student!';
console.log(text.rainbow);
```

Виконаємо команди в консолі:

```
npm i colors
node index.js
```

І тепер наш напис має стати різнобарвним.

## Модульність для вашої програми

Тепер у вас є файл `index.js`, тому настав час перейти на наступний рівень! Давайте створимо щось складніше, розділивши наш вихідний код на кілька JavaScript-файлів з метою зручності читання та підтримуваності. Щоб почати роботу, поверніться у свою IDE і створіть наступну структуру каталогів (з порожніми файлами), але доки не чіпайте `package.json`, ми згенеруємо його автоматично на наступному кроці:

```

├── app

| ├── calc.js

| └── index.js

├── index.js

└── package.json

```

І тепер наш напис має стати різнобарвним.

## Модульність для вашої програми

Тепер у вас є файл `index.js`, тому настав час перейти на наступний рівень! Давайте створимо щось складніше, розділивши наш вихідний код на кілька JavaScript-файлів з метою зручності читання та підтримуваності. Щоб почати роботу, поверніться у свою IDE і створіть наступну структуру каталогів (з порожніми файлами), але доки не чіпайте `package.json`, ми згенеруємо його автоматично на наступному кроці: Кожен проект Node.js починається зі створення файлу `package.json `. Ви можете думати про нього як про JSON-подання програми та її залежностей. Він містить ім'я вашої програми, автора (вас) та всі залежності, необхідні для запуску програми.

Ви можете інтерактивно генерувати файл `package.json` за допомогою команди `npm init` у терміналі. Після запуску команди вас попросять ввести деякі дані, наприклад, ім'я вашої програми, версію, опис і так далі. Не потрібно турбуватися, просто натискайте Enter, доки не отримаєте сформований JSON і питання `is it ok?`. Натисніть Enter в останній раз і вуаля: ваш package.json був автоматично згенерований і поміщений в папку вашої програми.

Можна скоротити процес і відразу задати `npm init-y`. І вже готовий файл `package.json` редагувати у вашому IDE.

Якщо ви відкриєте згенерований package.json у своїй IDE, він буде дуже схожий на фрагмент коду нижче.

```javascript

// package.json

{

"name": "@node-project",

"version": "1.0.0",

"description": "",

"main": "index.js",

"scripts": {

"test":  "echo \"Error: no test specified\" && exit 1",

"start":  "node index.js"

},

"author": "", "license": "ISC"

}

```

Хорошою практикою є додавання стартового скрипту до вашого пакету `package.json`. Як тільки ви це зробите, як показано в прикладі вище, ви можете запустити програму за допомогою команди `npm start`. Це дуже зручно, коли ви хочете розгорнути свою програму у провайдера PaaS: вони можуть розпізнати команду `start` і використовувати її для запуску програми.

Тепер повернімося до першого створеного вами файлу під назвою `index.js`. Я рекомендую залишити цей файл дуже компактним: тільки підключення самої програми (файл `index.js` з підкаталогу `/app`, створеного раніше). Скопіюйте наступний код у свій файл `index.js` та збережіть:

```javascript
// index.js

require("./app/index");
```

Тепер настав час розпочати створення реального додатку. Відкрийте файл `index.js` із папки `/app`, щоб створити дуже простий приклад: додавання масиву чисел. У цьому випадку файл `index.js` міститиме лише числа, які ми хочемо додати, а логіка, що вимагає обчислень, має бути поміщена в окремий модуль.

Вставте цей код у файл `index.js` у каталозі `/app`.

```javascript
// app/index.js

const calc = require("./calc");

const numbersToAdd = [
  3,

  4,

  10,

  2,
];

const result = calc.sum(numbersToAdd);

console.log(`The result is: ${result}`);
```

Тепер вставте фактичну бізнес-логіку у файл `calc.js`, який можна знайти у тій самій папці.

```javascript
// app/calc.js

function sum(arr) {
  return arr.reduce(function (a, b) {
    return a + b;
  }, 0);
}

module.exports.sum = sum;
```

Щоб перевірити, чи все ви зробили правильно, збережіть ці файли, відкрийте термінал і введіть 'npm start' або 'node index.js'. Якщо ви все зробили правильно, ви отримаєте відповідь: 19. Якщо щось пішло не так, уважно перегляньте лог у консолі та знайдіть проблему на його основі.

---

Для прикладу можете запустити два проекти (/00_1_Alert, /01_2_Variable), які лежать у каталозі lesson_1/01_Introduce to NodeJS. Необхідно перейти у відповідну папку, відкрити термінал і ввести 'node index.js'.

