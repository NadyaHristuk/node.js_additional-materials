# Ваш первый сервер на Node.js

## Модуль `http` для вашего Node.js-сервера

Как было уже сказано, Node ничего не может делать сам по себе.
Когда вы начинаете создавать HTTP-приложения в Node.js, встроенные модули `http/https` - это то, с чем вы будете взаимодействовать.

Давайте создадим ваш первый HTTP-сервер на Node.js! Нам будет нужно подключить модуль `http` и привязать наш сервер к порту `3000`.

```javascript
// содежимое index.js
const http = require('http') // require('http2'); require('https'); 
// дока на протоколы структуры файлов таких как .xml .svg ipv4 ipv6 ftp и многое другое 
//  RFC HTTP    ---  https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_RFC
const port = 3000

const requestHandler = (request, response) => {
    console.log(request.url)
    response.writeHead(200, {'Content-Type': 'text/plain'});
    response.end('Hello Node.js Server!')
}

const server = http.createServer(requestHandler)

server.listen(port, (err) => {
    if (err) {
        return console.log('something bad happened', err)
    }

    console.log(`server is listening on ${port}`)
})
```

Затем запускаем этот скрипт:

```javascript
$ node index.js
```
Ещё раз: это базовый веб-сервер, а не сервер с полным функционалом. Он не может обслуживать картинки или HTML-файлы. На самом деле, какой бы вы ни отправили запрос, он возвратит “Hello Node.js Server!”. Однако, вы можете запустить этот скрипт, перейти по адресу http://localhost:3000 в своем браузере и увидеть этот текст.

Первая строка подключает http-модуль, который поставляется вместе с Node.js и делает его доступным через переменную http.

Далее, мы вызываем одну из функций http-модуля createServer. Эта функция возвращает объект, имеющий метод listen, принимающий числовое значение порта нашего HTTP-сервера, который необходимо прослушивать.

Мы создаем сервер и передаём функцию в созданный им метод. Всякий раз, когда наш сервер получает запрос, переданная нами функция будет вызываться.

Этот принцип называется обратный вызов или callback. Мы передаём в некоторый метод функцию и этот метод исполняет её, когда происходит связанное с методом событие.

Что нужно здесь отметить:
* `requestHandler`: **эта функция будет вызываться каждый раз, когда на сервер придёт запрос**. Если вы откроете в своём браузере адрес `localhost:3000`, два сообщения появятся в консоли: одно для `/` и одно для `favicon.ico`.
* `if (err)`: обработка ошибок: если порт уже занят или есть какие-то другие причины, по которым сервер не может быть запущен, мы получим уведомление об этом.

Когда запускается наша функция и срабатывает, в неё передаются 2 параметра: request и response.

Они являются объектами и вы можете использовать их методы для обработки пришедшего HTTP-запроса и ответа на запрос (то есть, просто что-то посылать по проводам обратно в браузер, который запрашивал ваш сервер).

И наш код делает именно это: Всякий раз, когда запрос получен, он использует функцию response.writeHead() для отправки HTTP-статуса 200 и Content-Type в заголовке HTTP-ответа, а функцию Response.Write() или res.end для отправки текста «Hello Node.js Server!» в теле HTTP-ответа.
response.end() вызывается, чтобы завершить наш ответ.

На данный момент, мы не заботимся о деталях запроса, поэтому мы не используем объект request полностью.

Модуль `http` крайне низкоуровневый: создание сложного веб-приложения с использованием вышеприведенного фрагмента кода очень трудоемко. Именно по этой причине мы обычно выбираем фреймворки для работы над нашими проектами. Есть множество фреймворков, вот самые популярные:
* [express](http://expressjs.com/)
* [hapi](https://hapijs.com/)
* [koa](http://koajs.com/)
* [restify](http://restify.com/)

*В эследующих частях мы будем использовать Express, так как именно для него вы можете найти множество модулей в NPM.*



