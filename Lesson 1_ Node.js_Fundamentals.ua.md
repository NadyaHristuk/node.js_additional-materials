
## 1 дз

По 1 дз - если все понятно, то не читаем, если не понятно, то может, это вам поможет
## **Кака работать с  yargs в switch**
Давайте с начала - в вашей домашней работе предполагается реализовать методы работы с файлом: чтение из него всех данных и вывод в консоль, добавление данных, удаление данных и поиск по id.
Но как мы можем вызвать ту или иную функцию на выполнение. Для этого нам надо как-то в скрипт передать данные.
Для этих целей используется **модуль yargs**
он позволяет передавать в виде аргументов данные, которые могут обрабатываться внутри вашего скрипта.
что бы просто запустить на выполнение код из файла в ноде надо написать node и название того файла который вы хотите запустить. В вашей дз это `node index.js`
 Но нам надо как-то передать в этот файл параметры, что бы можно было вызвать на выполнение конкретную функцию
 `node index.js --action="list"`
вот тут происходит запуск файла index.js и передача аргумента `--action="list"`
как он будет обрабатываться в самом скрипте
сначала подключаем вначале файла нужный нам модуль - `const argv = require('yargs').argv; `  берем из него возможность работы с аргументами.
дальше создаем функцию которая принимает аргументы  - `function invokeAction({ action, id, name, email, phone })`
 и вызываем ее  -` invokeAction(argv);` -
если мы запустим наш скрпит с аргументами node` index.js --action="list" `- то в функцию попадает флаг `--action `со значением` list`
дальше управление передается на
`switch (action) {`
и тут будет происходить поиск
    case 'list':
      // ...
      break;
ответа со значением` list`
аналогично отработают все остальные **action**, которые вы передадите какждый раз запуская скрипт с разными аргументами
`node index.js --action="get" --id=5`

#####Добавялем контакт
`node index.js --action="add" --name="Mango" --email="mango@gmail.com" --phone="322-22-22"`

#####Удаляем контакт
`node index.js --action="remove" --id=3`
если вы попробуете вызвать ваш скрипт НЕ передав аргументы  - node index.js - вы попадете на ветку -


       default:
          console.warn('\x1B[31m Unknown action type!');
и увидите в консоли ошибку красного цвета - с сообщением, что это не известный **вид action**
**Красный цвет обеспечивает  - \x1B[31m**
Вот таким методом работает в связке argv и switch
что бы в простом виде посмотреть как это работает можете написать как-то так


     // index.js
    const argv = require('yargs').argv;
    
    // TODO: рефакторить
    function invokeAction({ action, id, name, email, phone }) {
      switch (action) {
        case 'list':
          console.log('list')
          break;
    
        case 'get':
           console.log('id',id)
          break;
    
        case 'add':
         console.log( 'name email phone', name, email, phone)
          break;
    
        case 'remove':
          console.log('id',id)
          break;
    
        default:
          console.warn('\x1B[31m Unknown action type!');
      }
    }
    
    invokeAction(argv);
и запустите этот скрпит с предложенными вам методами
`node index.js --action="list"`

###### Получаем контакт по id
node index.js --action="get" --id=5

###### Добавялем контакт
node index.js --action="add" --name="Mango" --email="mango@gmail.com" --phone="322-22-22"

###### Удаляем контакт
node index.js --action="remove" --id=3

Ну а дальше вам надо прописывать методы в самом **contact.js** экспортировать их из файла и импортировать в файле index.js и вызывать их в соответствующих case

## Как добавить пользовательский скрипт в мой файл package.json, который запускает файл index.js?
При выполнении команды `npm start` в каталоге проекта, будет выполнятся команда `node index.js` . И тем самым будет запускаться на выполнение файл** index.js**
Вот что надо записать в файле **package.json**


    "scripts": {
        "start": "node index.js"
    }
** Поле «script»**
Возможно вы этого не знали, но npm содержит поле под названием scripts в файле package.json проекта для того, чтобы делать такие команды, как npm test, фактически, выполняющая содержимое поля scripts.test, и npm start, вызывающая инструкции из поля scripts.start.
**npm test и npm start** — это, всего лишь, удобные ссылки для npm run test и npm run start. С помощью npm run можно выполнить совершенно любое содержимое любого поля внутри scripts.
__________________________
### npm - главные скрипты
npm - главные скрипты  - такие как запуск, остановка, перезагрузка, установить, версия или тест не требует выполнить команду. Эти сценарии и некоторые другие описаны в документации npm. И выполняются они через написание директивы npm и указания самой команды - например.
**npm start**
Остальные пользовательских скрипты npm, что бы вызвать вам нужно добавить run перед именем скрипта **npm run dev**
`npm run dev`
Абсолютно у всех разработчиков знакомство с nodejs начинается с того, что после каждого изменения нужно перезагружать сервер. Поэтому, появляется вопрос,  как сделать так, чтобы сервер перегружался автоматически.
Самый популярный вариант - **это nodemon.** То есть идея состоит в том, что в development окружении мы хотим, чтобы nodemon следил за файлами, которые мы меняем и просто перезапускал сервер, если эти файлы относятся к серверу.
Необходимо установить локально в наш проект как devDependencies nodemon.
`npm i -D nodemon`
или
`yard add nodemon`
Теперь давайте в package json добавим команду для него.


    "scripts": {
      "dev": "nodemon index.js"
    }
Теперь в консоли давайте запустим его командой
`npm run dev`
Как мы видим он запустился. Нам вывелось, что он вотчит все файлы в нашей папке и запускает команду node index.js при изменении любого файла.
Теперь, если мы изменим наш index.js, то nodemon перезапустит сервер.
Итого


    "scripts": {
        "start": "node index.js",
        "dev": "nodemon index.js"
      },
**В 1 ДЗ СКРИПТЫ ЗАПУСКАТЬ БЕЗПОЛЕЗНО - ВЫ НИЧЕГО НЕ УВДИТЕ!!! ОНИ У ВАС НЕ ВЫПОЛНЯТСЯ ПРАВИЛЬНО!!**
Вы сможете с ними нормально работать только со 2 дз!!
ЕСЛИ ЗАПУСТИТЕ СКРИПТЫ сейчас - ТО ПОЛУЧИТЕ ОШИБКУ - почему, потому что **вы вызывает index.js без аргументов и попадаете в ветку**


    default:
          console.warn('\x1B[31m Unknown action type!');
И ЕЕ ЖЕ УВИДИТЕ В КОНСОЛИ!!!
Что почитать - https://habr.com/ru/company/ruvds/blog/458504/ 

#### для подключения файлов необходимо использовать метод
`path.join([path1][, path2][, ...]) `— Объединяет все аргументы и нормализует полученный путь.
для получения точки отсчета - откуда надо проложить путь к нужному файлу используется **__dirname **- возвращает путь к каталогу текущего исполняемого файла.  И указываем путь  к файлу который хотим подключить.
`const path = require('path');`

`const absolutePath = path.join(__dirname, './db/contacts.json');`


### Как экспортировать функции из файла и импортировать?
При разделении программного кода на несколько файлов module.exports используется передачи переменных и функций для использования в том месте, где будет вызван этот модуль.
Если вы просто хотите выставить только одну функцию или переменную , например:


    // test.js
    var name = 'william';
    
    module.exports = function(){
        console.log(name);
    }   



    // index.js
    var test = require('./test');
    test();
этот модуль предоставляет только одну функцию, и свойство name является локальным и недоступным для внешнего модуля, в котором подключается `'./test' .`
______________________________
Если необходимо экспортировать несколько функций или переменных - то можно передать в module.exports объект:


    //data.js
    
    module.exports = {
        getContacts,
        getById
    }


    //app.js
    const functions = require('./data.js');
    functions.getContacts();
    functions.getById();
или можно


    const { getContacts, getById } = require('./data.js');
    getContacts();
    getById();

### разница const fs = require('fs').promises и const fs = require('fs')
Изначально модуль написан с использованием call-back функций и вызывался через ` const fs = request("fs")`
Дальше js развивается и уже никто не пишет на call-back функциях, потому что это устаревший стиль и еще колл-бак ад. Тогда в модуль добавили поддержку промисов,  Теперь можно использовать функции, но работать с ними не через коллбаки, а через промисы.  Соответвенно надо подключить работу с промисами `const fs = require('fs').promises`
Сейчас уже работают, не через промисы, а через обвертку над промисами async /await. Это сокращает код и делает его более читабельным
Если собираетесь использовать колбеки, то подключаете библиотеку без промисов.
Давайте поговорим о базовом JS
Что такое колбэки - "В функции, которые выполняют какие-либо асинхронные операции, передаётся аргумент callback — функция, которая будет вызвана по завершению асинхронного действия"
когда они используются? - когда есть «асинхронность» (когда какой-то процесс  будет завершен не сейчас, а потом)


    function НазваниеФункции (аргументы, callback) {
     ......(какой-то код)
    }
Теперь работа с самой функцией колбека


    function НазваниеФункции (аргументы, function(error, data) {
      if (error) {
        // обрабатываем ошибку
      } else {
        // успешно выполнено
      }
    });
такой подход называется «**колбэк с первым аргументом-ошибкой**» («error-first callback»).
**Правила таковы:**
Первый аргумент функции callback зарезервирован для ошибки. В этом случае вызов выглядит вот так: callback(err).
Второй и последующие аргументы — для результатов выполнения. В этом случае вызов выглядит вот так: `callback(null, result1, result2…).`
Одна и та же функция callback используется и для информирования об ошибке, и для передачи результатов.
теперь то, как это выглядит применительно к вашей 1 дз и к первой функции


    function listContacts() {
      fs.readFile(contactsPath, (err, data) => {
        if (err)  return console.error(err.message);
          console.table(JSON.parse(data.toString()));
      });
    }
это если мы собираемся в основном файле просто вызвать функцию listContacts()
Если вы хотите вернуть данные и уже в основном файле и обработать и вывести их в консоль, то


    function listContacts() {  
    fs.readFile(contactsPath, (err, data) => {    
    if (err) return console.error(err.message);     
       return data;  
    });  
    return JSON.parse(list);
    }
тогда в основном файле вы можете вызвать 

    listContacts().then(data => console.table(data)

#### Потом эволюция дошла до промисов, Потом эволюция дошла до промисов,
`const fs = require('fs').promises`
Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.
promise.then навешивает обработчики на успешный результат или ошибку
Если очередной then вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.
Если then возвращает промис, то до его выполнения может пройти некоторое время, оставшаяся часть цепочки будет ждать.
То есть, логика довольно проста:
В каждом then мы получаем текущий результат работы.
Можно его обработать синхронно и вернуть результат (например, применить JSON.parse). Или же, если нужна асинхронная обработка – инициировать её и вернуть промис.
При возникновении ошибки – она отправляется в ближайший обработчик onRejected.
Такой обработчик нужно поставить через второй аргумент .then(..., onRejected) или, что то же самое, через .catch(onRejected).
Чтобы поймать всевозможные ошибки, которые возникнут при загрузке и обработке данных, добавим catch в конец цепочки
`promise.then(onFulfilled, onRejected)`
пример первой функции з дз на чистых промисах


    function listContacts() { 
    readFile(contactsPath,'utf-8')
    .then(data => console.log(JSON.parse(data))
        .catch(err => console.log(err))
    }
Если собираемся вернуть данные в основной файл
 

    function listContacts() { 
    const list = readFile(contactsPath,'utf-8')
    .then(data => return JSON.parse(data))
        .catch(err => console.log(err))
    return list
    }

#### Async/await
Существует специальный синтаксис для работы с промисами, который называется «async/await». Он удивительно прост для понимания и использования.
По сути, это просто «синтаксический сахар» для получения результата промиса, более наглядный, чем promise.then.
Что бы переписать функцию на промисах с помощью async/await:
Нам нужно заменить вызовы .then на await.
И добавить ключевое слово async перед объявлением функции.


    async function listContacts() => {
      const res = await readFile(contactsPath);
      console.log(res)
    }
Ошибки можно ловить, используя try..catch, как с обычным throw
В случае ошибки выполнение try прерывается и управление прыгает в начало блока catch. Блоком try можно обернуть несколько строк:


    async function listContacts() {
      try {
        const data = await fs.readFile(contactsPath);
        const result = JSON.parse(data);
        console.table(result);
      } catch (error) {
        console.log(error);
      }
    }
Если собираемся вернуть данные в основную функцию


    async function listContacts() {
      try {
        const data = await fs.readFile(contactsPath);
        const result = JSON.parse(data);
         return result;  
      } catch (error) {
        console.log(error);
      }
    }
Что дополнительно почитать:
https://habr.com/ru/company/skillbox/blog/458950/

#### Для чего нужен файл .gitignore?
Для чего нужно использовать файл .gitignore, если можно просто выбрать файлы которые необходимо закоммитить, и сделать это?
Есть несколько задач, которые наиболее эффективно решаются с использованием файла .gitignore:
Не мучаться с выбором нужных файлов для индексации (которая git add).
В большом проекте часто бывает много файлов, которые не подлежат версионированию. А ещё вам может быть удобно хранить какие-то промежуточные результаты в папке tmp.
Настройка .gitignore позволяет не выискивать нужные файлы, а добавлять всё сразу или по крайней мере уточнять меньше.
Сделать локальный конфиг, который не будет затронут pull-ом.
Защитить чувствительную информацию от случайного раскрытия.
Случается, что вы случайно добавили и закоммитили ключи или пароли от какого-нибудь облачного хранилища, например Amazon.
Если так уж необходимо хранить чувствительную информацию в папке проекта, то нужно положить её в под-папку, игнорируемую git.
Быстро очищать проект от временных файлов.
Предположим, что вы пишете на компилируемом языке и при построении вашего проекта формируется множество промежуточных файлов (объектные, прекомпиляция, вот это всё). Перед каждой сборкой необходимо их удалять, чтобы в случае чего не прилинковать лишнее. Можно делать это вручную. Можно написать скрипт. А можно просто добавить их в .gitignore и делать так:
git clean -fX
________________________________________________
файл  .gitignore - можно сгенерировать и тогда вам самостоятельно надо разбираться с теми зависимостями, которые туда добавил генератор  .gitignore
или вы можете собрать самостоятельно создав в корне проекта файл  .gitignore: и добавить туда ту информацию по вашему проекту, которую необходимо не загружать на гит.
 комментарий — эта строка игнорируется
 не обрабатывать файлы, имя которых заканчивается на .a
*.a
 НО отслеживать файл lib.a, несмотря на то, что мы игнорируем все .a файлы с помощью предыдущего правила
!lib.a
 игнорировать только файл TODO находящийся в корневом каталоге, не относится к файлам вида subdir/TODO
/TODO
 игнорировать все файлы в каталоге build/
build/
 игнорировать doc/notes.txt, но не doc/server/arch.txt
doc/*.txt
 игнорировать все .txt файлы в каталоге doc/
doc/**/*.txt
_______________________________________________________________________
Какая задача на этапе 1 дз - убрать папку node_modules
├── js
│   ├── app.js
│   └── system.js
├── scss
│   ├── system.scss
│   └── theme.scss
└── node_modules       <-- Убрать
    │   ├── load-json-file
    │   ├── lodash
    │   ├── jquery
    │   ├── make-error
    │   ├── semantic
    │   └── yargs
    └── semantic.json

##### Решение:
node_modules/*
_____________________________________
Как игнорировать файлы, которые уже отслеживаются?
Если вы добавили файл или папку в .gitignore, после того как они попали в репозиторий, то их необходимо удалить из репозитория командой:
`git rm --cached <file>`
Например убрать папку storage/framework/cache/. Обратите внимание: вначале отсутствует слеш.
git rm -r --cached "storage/framework/cache/"
что почитать на тему - https://devacademy.ru/article/ignorirovanie-faylov-i-katalogov-v-git
