 Начиная ***со второй домашней работы***, добавьте меня, пожалуйста, в коллабораторы - мой ник на гит-хабе - **NadyaHristuk**
Зачем меня добавлять в коллабораторы - такое условие по сдаче ваших работ по курсу Node.js - https://github.com/goitacademy/nodejs-homework
______________________________________________________________________
**Как добавить в коллабораторы** - заходим на сайт https://github.com/ - открываем нужный нам репозиторий, над кодом есть панель управления и крайняя справа клавиша - настройки (Settings) - дальше  - Manage access - вводим пароль - ищем большую зелененькую клавишу - "Invite a collaborator" - в появившейся всплывашке вводим мой ник - NadyaHristuk и нажимаем -   Add  to this repository
______________________________________________________________________
##### Зачем вам нужны ветки? и зачем меня добавлять в коллабораторы.
Это приближенный вариант работы над проектом над реальным проектом.
Обычно в проекте есть много веток, каждую "фичу" дорабатывают в отдельной ветке, потом делают пул-реквест, на слияние с основной веткой. Ваш тим-лид проверяет ваш код и сливает с основной веткой, или пишет замечания и отправляет на доработку.
Дз сделанны по такому принципу, что вы от работы к работе добавляете "фичи" и расширяете основной проект. Каждую дз вы делаете в отдельной ветке, и делаете пул-реквест на добавление этого кода в основную ветку. Я ваш "тим-лид" который на время курса по Node.js, проверяю ваш пул-реквест, если все хорошо, я добавляю ваш код в основную ветку. Если есть замечания я вам из отписываю в пул-реквесте.
А в основной ветке у вас всегда самый актуальный код.
______________________________________________________________________
## По 2 дз :
в бойлерплейте дан метод PATCH а в ДЗ требуют прописать PUT. Cтоит переименовывать метод на PUT?
В условиях 2 дз - нет значения - что возьмете - то и хорошо.
##### **Если дотошничать.**
**"PATCH** используется для частичного изменения ресурса. PUT создает новый ресурс или заменяет представление целевого ресурса, данными представленными в теле запроса.
Иными словами, в PATCH вложенный объект содержит набор инструкций, описывающих, как ресурс, находящийся в данный момент на исходном сервере, должен быть модифицирован для создания новой версии. А в PUT содержится новая версия ресурса целиком.
В отличие от PUT, PATCH не идемпотентный, это подразумевает что успешные идентичные PATCH запросы могут иметь отличные эффекты. Однако, возможно выдавать запросы PATCH таким образом, чтобы они были идемпотентные.

.....

**UPDATE**
PATCH не является идемпотентным (одноитоговым), т.к. в него можно вставить инструкцию добавления элемента. Тогда повторный запрос добавит его еще раз. А вот PUT просто перезаписал бы ресурс целиком (снова), т.е повторный запрос не приводит к разным результатам. Другие примеры: GET запрос идемпотентный: сколько бы раз ты не запрашивал в Google некоторый запрос, Google вернет тебе тот же результат. POST не идемпотентный: он может вставлять в базу новую строку каждый раз."
______________________________________________________________________
### О схеме валидации данных при обновлении 
Пожалуйста, создавайте две отдельные схемы. Почему, потому что при создании вам ОБЯЗАТЕЛЬНО нужны ВСЕ поля заполненные. А при обнвлении достаточно хотя бы ОДНОГО поля, для обновления записи. По этому нам над две отдельные схемы. При валидации контактов, которые приходят к вам для обновления необходимо убедится, что к вам пришло хотя бы одно поле на обновление
 ```javascript
   const schemaUpdate = Joi.object({
      name: Joi.string()    
      email: Joi.string()
      phone: Joi.string()
    }).min(1) 
```
- надо дописать - .min(1) - что минимально придет хотя бы одно поле на обновление
______________________________________________
```javascript
    const schemaUpdate = Joi.object({
      name: Joi.string()    
      email: Joi.string()
      phone: Joi.string()
    })
```
`.or("name", "email", "phone")` что минимально придет хотя бы одно поле на обновление
`.or("name", "email", "phone")` или` .min(1);` - делает одно и тоже.
______________________________________________
###  Я вам сейчас расскажу страшно крамольную штуку, только обещайте меня сильно не выдавать.
~~немного про 1 и 2 дз - файл с данными, используется только в 1 и 2 дз вместо настоящей базы данных.
По этому функции для вот именно такой работы с записью и чтением данных из файла и в файл, вы будете использовать только в 1 и 2 дз ,
То есть все ваши фильтры, файнды. пуши и спреды - это вы потренировали знание базового Джава Скрипта.
Потому что сразу с 1 урока не получится дать вам работу с базой, потому что сразу прийдется рассказать очень много информации, которую за один урок не получится всю сразу успеть осознать и понять.
По этому вы поэтапно учитесь -
Что надо было научиться на 1 дз это - создание базового проекта (npm init -y), запуск приложений, через скрипты, установка модулей, подключение модулей и экспортирование/импортирование функций в файлах и работа с функциями из базовых модулей (читать документацию).
Как бы фильтры, пуш и т.д - то, что используется в 1 дз - нигде и никогда не будет применятся, кроме 1 и 2 дз. Потому что это подводящие дз к основной работе с нодой.
Никто в ноде не работает с записями в файл. Это имитация работы с базой на 1 и 2 дз, что бы у вас был хоть какой-то аналог базы. В реальной разработке нигде не применяется
2 дз посвящена созданию базового сервера и пониманию того, как происходит разбитие функций по файлам и архитектуре + проверка входящих данных. Это самое важное. Работа с файлом и функции из базового ДС это всего лишь как дополнение. что бы вам было не скучно.
С 3 дз у вас уже будет сервер и работа с БД, и вот с этого момента начинается настоящая нода. Но там и свои функции для работы с базой и свои методы для получения ответа от БД в разных форматах - и да, это важно уметь работать с БД, А желательно и не с одой и знать запросы к реляционным и не реляционным базам". И теперь есть еще модный GraphQL, который по сути заменят Express. А еще есть и Koa. В общем есть с чем разбираться кроме тренировок с базовыми функциями JS.
О чем это я, - если вы решили, что надо довести до идеала 1 и 2 дз и натренироваться с FS. Подумав, что это наверно очень важные основы ноды, и как бы важный фундамент для всей последующей ноды - то неть ))
и не затягивайте сдачау 2 дз )) настоящая Нода впереди! да и сложные структуры проектов тоже впереди.~~**

_____________________________________________
### Morgan, что за зверь? и с чем его едят. 
```javascript
`const logger = require('morgan')`
```
morgan библиотека для логирования. Она подключается как прослойка (middleware)
`const formatsLogger = app.get('env') === 'development' ? 'dev' : 'short' `- позволяет выводить логирование или в варианте  'dev' 'short' - в зависимости от стадии разработки проверка - 'development' или нет.

```javascript
app.use(logger(formatsLogger))
```
**Что такое логирование** - когда вы будете делать к вашему API (это ваш сервер) запросы через Постмен, то в консоли, вы будете видеть, что то вот такого типа
```javascript
info: ::1 - - [16/Feb/2018:12:37:44 +0000] "GET /logout HTTP/1.1" 200 34 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"
timestamp=2018-02-16T12:37:44.421Z 
```
И вот эта информация и называется - **логирование**
**В чем смысл** - мы делаем запрос, запрос проходит через эту прослойку,  и эта прослойка присылает в консоль информацию про запрос - когда, какой, на какой адрес, какой код ответа. Или сообщает, что произошла ошибка
 **Зачем это надо?** Потому что тут вы сами себе присылаете запросы. Но обычно вы на сервере просто видите, как пользователи из разных точек мира шлют запросы на сервер, и вы видите какие запросы приходят, как их много, какие ответы - положительные или ошибки. Это такой журнал наблюдения за работой вашего сервера.  Что бы потом, когда что-то не так пойдет, вы поднимаете такой журнал и смотрите, что вот после запроса на такой-то роут, в такое-то время с такими-то параметрами - ваш сервер умер. Значит там у нас проблемы. Можно не в консоль писать, можно писать в файл
```javascript
var accessLogStream = fs.createWriteStream(path.join(__dirname, 'access.log'), { flags: 'a' })
```

```javascript
app.use(morgan('combined', { stream: accessLogStream }))
```
Это из примера самой библиотеки, если будете использовать, только вары замените.
_____________________________________________________
### Если вы вот этот пример находили в конспекте и не разобрались что это такое.
```javascript
req.session.views = req.session.views === void 0 ? 0 : ++req.session.views
```
немного гугления и  -
"void(0) — это выражение, получающееся приведением типа константы 0 к void. То есть простое ничего не значащее выражение."
___________________________
"Цей оператор дозволяє обчислення виразів, які повертають значення, у місцях, де очікується вираз, що обчислюється як undefined.
Оператор void часто використовують лише для того, щоб отримати просту величину undefined, зазвичай, використанням "void(0)" (що є еквівалентним "void 0"). У таких випадках можна замість цього скористатись глобальною змінною undefined (за умови, що їй не було присвоєне нове значення)."
https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/void#%D0%BE%D0%BF%D0%B8%D1%81
___________________________
### Валидацию данных очень желательно выносить как прослойку и отделять от функций контроллеров.
Вдруг захотите валидацию вынести в роуты из контроллеров, и вынести отдельно схемы валидации. Покажу на примере немного не контактов, но как раз сможете разобраться, и пременить для контактов.
```javascript
router.post('/signup',
  validationRegLog, asyncWrapper(registrationController)
)

router.post('/login',
  validationRegLog, asyncWrapper(loginController)
)
```
а вот код схем.
```javascript
const Joi = require('joi')

const { Subscription } = require('../helpers/subscription')

const { STARTER, PRO, BUSINESS } = Subscription

const schemaRegLogUser = Joi.object({
  email: Joi.string()
    .email({
      minDomainSegments: 2,
      tlds: { allow: ['com', 'net', 'org', 'ru', 'ua'] }
    })
    .pattern(
      /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i
    )
    .required(),
  password: Joi.string()
    .pattern(/^((?=\S*?[A-Z])(?=\S*?[a-z])(?=\S*?[0-9]).{6,})\S$/)
    .required(),
  subscription: Joi.string().default(STARTER),
})

const schemaSubscriptionUser = Joi.object({
  subscription: Joi.any()
    .valid(STARTER, PRO, BUSINESS)
    .required(),
})

const validate = (schema, req, res, next) => {
  const validationData = schema.validate(req.body)

  if (validationData.error) {
    return res.status(400)
      .json({ message: validationData.error.message.replace(/"/g, '') })
  }
  next()
}

module.exports = {
  validationRegLog: (req, res, next) => {
    return validate(schemaRegLogUser, req, res, next)
  },
  validationSubscription: (req, res, next) => {
    return validate(schemaSubscriptionUser, req, res, next)
  }
}
```
____________________________________________
### Если вам сложно и плохо дается в понимании **как сделать 2 дз **- может вам помогут эти ссылочки

https://lo-victoria.com/build-a-rest-api-with-nodejs-routes-and-controllers

https://developer.mozilla.org/ru/docs/Learn/Server-side/Express_Nodejs/routes

https://metanit.com/web/nodejs/7.1.php

https://monsterlessons.com/project/lessons/express-router 

